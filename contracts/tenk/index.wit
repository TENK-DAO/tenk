// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (cargo-witgen v0.12.0) 


///  milliseconds elapsed since the UNIX epoch
type timestamp-ms = u64

///  Create a pending token that can be claimed with corresponding private key
///  change
create-linkdrop: function(public-key: public-key)
///  Returns the balance associated with given key.
get-key-balance: function() -> u128

check-key: function(public-key: public-key) -> bool

get-linkdrop-contract: function() -> account-id

///  @allow ["::admins", "::owner"]
///  change
transfer-ownership: function(new-owner: account-id) -> bool

///  @allow ["::admins", "::owner"]
///  change
update-initial-royalties: function(initial-royalties: royalties) -> bool

///  @allow ["::admins", "::owner"]
///  change
update-royalties: function(royalties: royalties) -> bool

///  @allow ["::admins", "::owner"]
///  change
update-allowance: function(allowance: u32) -> bool

///  @allow ["::admins", "::owner"]
///  change
update-uri: function(uri: string) -> bool

///  @allow ["::admins", "::owner"]
///  change
add-whitelist-accounts: function(accounts: list<account-id>, allowance: option<u32>) -> bool

///  @allow ["::admins", "::owner"]
///  change
update-whitelist-accounts: function(accounts: list<account-id>, allowance-increase: u32) -> bool

///  End public sale/minting, going back to the pre-presale state in which no one can mint.
///  @allow ["::admins", "::owner"]
///  change
close-sale: function() -> bool

///  Override the current presale start time to start presale now.
///  Most provide when public sale starts. None, means never.
///  Can provide new presale price.
///  Note: you most likely won't need to call this since the presale
///  starts automatically based on time.
///  @allow ["::admins", "::owner"]
///  change
start-presale: function(public-sale-start: option<timestamp-ms>, presale-price: option<u128>) -> bool

///  @allow ["::admins", "::owner"]
///  change
start-sale: function(price: option<yocto-near>) -> bool

///  Add a new admin. Careful who you add!
///  @allow ["::admins", "::owner"]
///  change
add-admin: function(account-id: account-id) -> bool

///  Update public sale price. 
///  Careful this is in yoctoNear: 1N = 1000000000000000000000000 yN
///  @allow ["::admins", "::owner"]
///  change
update-price: function(price: u128) -> bool

///  Update the presale price
///  Careful this is in yoctoNear: 1N = 1000000000000000000000000 yN
///  @allow ["::admins", "::owner"]
///  change
update-presale-price: function(presale-price: option<u128>) -> bool

///  Copied from https://github.com/near/NEPs/blob/6170aba1c6f4cd4804e9ad442caeae9dc47e7d44/specs/Standards/NonFungibleToken/Payout.md#reference-level-explanation
///  A mapping of NEAR accounts to the amount each should be paid out, in
///  the event of a token-sale. The payout mapping MUST be shorter than the
///  maximum length specified by the financial contract obtaining this
///  payout data. Any mapping of length 10 or less MUST be accepted by
///  financial contracts, so 10 is a safe upper limit.
///  This currently deviates from the standard but is in the process of updating to use this type
record payout {
    payout: list<tuple<account-id,u128>>
}

type basis-point = u16

record royalties {
    accounts: list<tuple<account-id,basis-point>>,
    percent: basis-point
}


///  String of yocto NEAR; 1N = 1000000000000000000000000 yN
type yocto-near = u128

record initial-metadata {
    name: string,
    symbol: string,
    uri: string,
    icon: option<string>,
    spec: option<string>,
    reference: option<string>,
    reference-hash: option<base64-vec-u8>
}

record sale {
    royalties: option<royalties>,
    initial-royalties: option<royalties>,
    presale-start: option<timestamp-ms>,
    public-sale-start: option<timestamp-ms>,
    allowance: option<u32>,
    presale-price: option<u128>,
    price: u128,
    mint-rate-limit: option<u32>
}

///  Current state of contract
enum status {
    ///  Not open for any sales
    closed,
    ///  VIP accounts can mint
    presale,
    ///  Any account can mint
    open,
    ///  No more tokens to be minted
    sold-out,
}


///  Information about the current sale from user perspective
record user-sale-info {
    sale-info: sale-info,
    is-vip: bool,
    remaining-allowance: option<u32>
}

///  Information about the current sale
record sale-info {
    ///  Current state of contract
    status: status,
    ///  Start of the VIP sale
    presale-start: timestamp-ms,
    ///  Start of public sale
    sale-start: timestamp-ms,
    ///  Total tokens that could be minted
    token-final-supply: u64,
    ///  Current price for one token
    price: u128
}



///  Current contract owner
owner: function() -> account-id

///  Current set of admins
admins: function() -> list<account-id>

///  Check whether an account is allowed to mint during the presale
whitelisted: function(account-id: account-id) -> bool

///  Cost of NFT + fees for linkdrop
cost-of-linkdrop: function(minter: account-id) -> u128

total-cost: function(num: u32, minter: account-id) -> u128

///  Flat cost of one token
cost-per-token: function(minter: account-id) -> u128

///  Current cost in NEAR to store one NFT
token-storage-cost: function() -> u128

///  Tokens left to be minted.  This includes those left to be raffled minus any pending linkdrops
tokens-left: function() -> u32

///  Part of the NFT metadata standard. Returns the contract's metadata
nft-metadata: function() -> nft-contract-metadata

///  How many tokens an account is still allowed to mint. None, means unlimited
remaining-allowance: function(account-id: account-id) -> option<u32>

///  Max number of mints in one transaction. None, means unlimited
mint-rate-limit: function() -> option<u32>

///  Information about the current sale. When in starts, status, price, and how many could be minted.
get-sale-info: function() -> sale-info

///  Information about a current user. Whether they are VIP and how many tokens left in their allowance.
get-user-sale-info: function(account-id: account-id) -> user-sale-info

///  Initial size of collection. Number left to raffle + current total supply
initial: function() -> u64

///  change
new-default-meta: function(owner-id: account-id, metadata: initial-metadata, size: u32, sale: option<sale>)
///  change
new: function(owner-id: account-id, metadata: nft-contract-metadata, size: u32, sale: sale)
///  change
nft-mint: function(token-id: token-id, token-owner-id: account-id, token-metadata: token-metadata) -> token

///  change
nft-mint-one: function() -> token

///  change
nft-mint-many: function(num: u32) -> list<token>
// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (witme v0.2.0) 

///  StorageUsage is used to count the amount of storage used by a contract.
type storage-usage = u64

///  Balance is a type for storing amounts of tokens, specified in yoctoNEAR.
type balance = u128

///  Represents the amount of NEAR tokens in "gas units" which are used to fund transactions.
type gas = u64

///  base64 string.
type base64-vec-u8 = string

///  Raw type for duration in nanoseconds
type duration = u64

///  @minLength 2
///  @maxLength 64
///  @pattern ^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$
type account-id = string

///  String representation of a u128-bit integer
///  @pattern ^[0-9]+$
type u128 = string

///  Public key in a binary format with base58 string serialization with human-readable curve.
///  The key types currently supported are `secp256k1` and `ed25519`.
/// 
///  Ed25519 public keys accepted are 32 bytes and secp256k1 keys are the uncompressed 64 format.
type public-key = string

///  Raw type for timestamp in nanoseconds
type timestamp = u64

// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (witme v0.1.0) 

///  In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
record token {
    token-id: token-id,
    owner-id: account-id,
    metadata: option<token-metadata>,
    approved-account-ids: option<list<tuple<account-id,u64>>>
}

record fungible-token-metadata {
    spec: string,
    name: string,
    symbol: string,
    icon: option<string>,
    reference: option<string>,
    reference-hash: option<base64-vec-u8>,
    decimals: u8
}

///  Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
type token-id = string

///  Metadata for the NFT contract itself.
record nft-contract-metadata {
    spec: string,
    name: string,
    symbol: string,
    icon: option<string>,
    base-uri: option<string>,
    reference: option<string>,
    reference-hash: option<base64-vec-u8>
}

record storage-balance-bounds {
    min: u128,
    max: option<u128>
}

///  Metadata on the individual token level.
record token-metadata {
    title: option<string>,
    description: option<string>,
    media: option<string>,
    media-hash: option<base64-vec-u8>,
    copies: option<u64>,
    issued-at: option<string>,
    expires-at: option<string>,
    starts-at: option<string>,
    updated-at: option<string>,
    extra: option<string>,
    reference: option<string>,
    reference-hash: option<base64-vec-u8>
}

record storage-balance {
    total: u128,
    available: u128
}

type wrapped-duration = string

